# 🌱 ジュニア開発者のためのリーン開発 × LLM入門  
## ― Proactive Delta Context と delta コマンドフロー ―

---

## 1. リーン開発とは？ ― ムダを削り、流れを止めない開発

リーン開発は、**ムダを最小化し、価値を滞りなく流す**ための開発の考え方です。  
もともとはトヨタ生産方式（TPS）から生まれたもので、「少ない資源で、高品質を維持し、流れを止めない」ことを目的としています。

ソフトウェア開発にもムダは多く存在します。  

| ムダの種類 | ソフトウェアでの例 |
|-------------|----------------------|
| 過剰生産 | 実際には使われない機能を先回りして実装 |
| 手待ち | レビュー・仕様待ちで開発が止まる |
| 過剰処理 | 必要以上の最適化や書き直し |
| 不良 | バグや誤仕様による再作業 |
| 余剰在庫 | 未リリースのコード・設計書 |
| 無駄な動作 | 重複する会議・承認 |
| 無駄な移動 | 情報が分断し、確認に時間を要する |

リーン開発の目的は、「**このムダを減らし、流れ（flow）を保つ**」こと。  
“早く作る”よりも、“止まらずに流れる”ことが重要なのです。

---

> **Context Delta ライブラリ** は、以下で説明する delta コマンド体系（`delta concept → delta archive`）を npm CLI と AI ワークフローで再利用できるようにまとめたものです。

## 2. LLM生成とムダ ― 「たくさん出す」は効率化ではない

LLM（大規模言語モデル）は、コードや設計文書を一瞬で生成できます。  
しかし、入力が曖昧だったり多すぎたりすると、  
- 不要な情報を含む出力  
- 変更前後の情報が混ざって矛盾する出力（ハルシネーション）  
- 修正の繰り返し  

といったムダが生じます。  

つまり、**「大量生成」＝「高効率」ではない**のです。  
リーンの観点では、これは「過剰生産」や「不良」の典型です。  

重要なのは、**必要なものを、必要なだけ、正確に流す**こと。  
これを実現するのが「Proactive Delta Context」です。  

---

## 3. Proactive Delta Context ― 変更差分に閉じた整流構造

### 定義
> **Proactive Delta Context** とは、  
> 変更や修正に必要な最小限の差分情報（Δ）だけを抽出し、  
> その範囲に閉じた文脈（context）で正確に処理を行う仕組みです。  

つまり、全体を再生成するのではなく、  
**「変えるべき箇所だけを最小限の文脈で流す」** という考え方です。  

これにより、  
- 無関係な部分への影響（ハルシネーション）を防止  
- 再計算・再検証・再構築のムダを削減  
- フロー全体を「止まらない状態」に保つ  

ことができます。  

リーン開発における「一個流し（one-piece flow）」の思想を、  
LLM時代の知的作業にそのまま適用したものといえます。  

---

## 4. delta フローとは？ ― 差分を流すための実装構造

この思想を実際の開発フローとして実現するのが、  
**`delta concept → delta propose → delta verify → delta apply → delta archive`**  
の一連のコマンドです。  

┌────────────┐
│ delta concept │ ← 上流：変更群の設計・方向付け
└─────┬──────┘
│
▼
┌────────────┐
│ delta propose │ ← 中流：個々の変更案の形成（差分単位）
└─────┬──────┘
│
▼
┌────────────┐
│ delta verify │ ← 品質ゲート（すべての段階に適用）
└─────┬──────┘
│
▼
┌────────────┐
│ delta apply │ ← 実装：変更案の適用・反映
└─────┬──────┘
│
▼
┌────────────┐
│ delta archive │ ← 終端：整流・履歴化
└────────────┘


---

## 5. 各コマンドの役割とリーン的効果

| コマンド | 主な出力 | 目的 | 得られるリーン的効果 |
|-----------|-----------|------|------------------------|
| **`delta concept`** | ・変更テーマ（どの流れを扱うか）<br>・影響範囲・ゴール・目的 | 上流で変更群の流れを設計し、範囲を定義 | ✅ **過剰生産の防止**：必要な変更群だけを扱う。<br>✅ **流れ設計（Value Stream Design）**：ムダを上流で断つ。 |
| **`delta propose`** | ・具体的な変更案（差分単位）<br>・理由と期待効果 | concept の枠内で、実際に差分単位の変更案を形成 | ✅ **過剰処理の削減**：必要最小限の変更だけを定義。<br>✅ **標準化の促進**：変更提案の形式を統一。 |
| **`delta verify`** | ・整合検証レポート<br>・rubric との一致率<br>・矛盾検知結果 | **全フェーズに横断適用**。concept / propose / apply / archive の品質を自動検証 | ✅ **自働化（jidoka）**：異常を即検知・即停止。<br>✅ **不良流出防止**：変更前後の不整合・矛盾（ハルシネーション）を防止。 |
| **`delta apply`** | ・適用結果（before / after diff）<br>・安定した成果物 | 差分を実際の成果物に反映し、流れを完了 | ✅ **一個流し**：差分単位で処理を通す。<br>✅ **手戻り削減**：全体再生成のムダを排除。 |
| **`delta archive`** | ・履歴・メタ情報・次 concept への参照 | フローの終端。成果を整流し、履歴化 | ✅ **在庫ゼロ化**：仕掛りや未処理を残さず流す。<br>✅ **継続整流**：次の concept へ最小限の情報を渡す。 |

---

## 6. delta verify ― 全フェーズに通底する「品質ゲート」

`delta verify` は特定の工程ではなく、  
**全てのフェーズを横断して流れる“自働化された品質ゲート”** です。  

| 適用フェーズ | 検証内容 | 効果 |
|---------------|------------|-------|
| **concept** | 範囲の妥当性、目的の明確さ | 変更範囲が大きすぎないか、曖昧でないかを検出 |
| **propose** | 差分の整合性・rubricとの一致 | 論理的矛盾や品質逸脱を防止 |
| **apply** | 適用結果の前後不整合 | 差分反映時の破損・依存ミスを検出 |
| **archive** | 履歴構造・参照の完全性 | 記録の欠落・誤リンクなどを防止 |

verify が存在することで、  
- 不良は必ず**工程内で止まる**（後戻りしない）  
- 正常な変更は**滞りなく流れる**（one-piece flow）  

という理想的な状態が実現します。  

---

## 7. フロー全体図

[delta concept] → [delta propose] → [delta apply] → [delta archive]
↑ ↑ ↑ ↑
└───────────── delta verify ─────────────┘
（各段階に自動品質ゲートを設置）


この構造によって、  
フロー全体が「止まらず」「壊れず」「滞留しない」。  
リーンでいう「**自働化と一個流しの両立**」が達成されます。  

---

## 8. リーン的観点で見た delta フローの効果

| フェーズ | 生成物 | 主なリーン効果 |
|-----------|----------|----------------|
| **concept** | 変更群の設計・流れの範囲 | 過剰生産の防止・ムダの源を上流で断つ |
| **propose** | 差分単位の変更案 | 過剰処理削減・標準化・小ロット化 |
| **verify（横断）** | 検証レポート | 自働化・異常即停止・工程内品質保証 |
| **apply** | 実際の変更結果 | 一個流し・再生成の排除・手戻り防止 |
| **archive** | 履歴・メタ情報 | 在庫ゼロ化・整流履歴・継続安定化 |

---

## 9. 結論：差分を流すことがリーンの本質

> **Proactive Delta Context** は、  
> 「変更差分だけを対象に、最小限の文脈で正確に処理する」仕組み。  
>  
> **delta フロー** は、それを現場で動かすための整流システムです。  
>  
> - `concept` が流れを設計し、  
> - `propose` が最小の変更を提案し、  
> - `verify` が全体の品質を守り、  
> - `apply` が差分を正確に流し、  
> - `archive` が滞留をなくす。  
>  
> この一連の流れが止まらず循環することで、  
> LLM開発は「全体再生成のサイクル」から「**差分を流すリーンな一個流し**」へと進化します。
